# HTTPS Migration Plan

## Overview

This plan addresses critical security vulnerabilities by migrating the entire application from HTTP to HTTPS protocol, including WebSocket connections from WS to WSS.

## Current State Analysis

### Identified Vulnerabilities

| Location | Line | Issue |
|----------|------|-------|
| `frontend/src/services/api/baseApi.ts` | 52, 55 | Hardcoded `http://` URLs |
| `frontend/src/services/api/viewerApi.ts` | 9, 11 | Hardcoded `http://` URLs |
| `frontend/src/services/realTimeService.ts` | 391, 393 | WebSocket uses `http://` (Socket.IO) |
| `backend/src/app.ts` | 6, 20, 27-28, 42-43 | HTTP server, HTTP CORS origins |
| `frontend/tests/*` | Multiple | Test fixtures using `http://` |

### Security Risks
- Man-in-the-middle attacks on all API calls
- Bearer token interception over plaintext HTTP
- WebSocket data exposed to network sniffing
- Session hijacking vulnerability
- No HSTS protection

---

## Implementation Plan

### Phase 1: Backend HTTPS Support

#### Step 1.1: Add SSL Environment Variables
**File:** `backend/src/config/env.ts`

Add new optional environment variables:
```typescript
interface OptionalEnv {
  NODE_ENV?: string;
  RATE_LIMIT_WINDOW_MS?: string;
  RATE_LIMIT_MAX_REQUESTS?: string;
  // New SSL configuration
  SSL_ENABLED?: string;           // 'true' or 'false'
  SSL_KEY_PATH?: string;          // Path to private key
  SSL_CERT_PATH?: string;         // Path to certificate
  SSL_CA_PATH?: string;           // Optional CA bundle path
  FORCE_HTTPS?: string;           // Force redirect HTTP to HTTPS
}
```

#### Step 1.2: Create SSL Configuration Utility
**File:** `backend/src/config/ssl.ts` (new file)

```typescript
import fs from 'fs';
import https from 'https';
import { Env } from './env';

export interface SSLConfig {
  enabled: boolean;
  options?: https.ServerOptions;
}

export function loadSSLConfig(env: Env): SSLConfig {
  const enabled = env.SSL_ENABLED === 'true';

  if (!enabled) {
    return { enabled: false };
  }

  const keyPath = env.SSL_KEY_PATH;
  const certPath = env.SSL_CERT_PATH;

  if (!keyPath || !certPath) {
    console.warn('SSL enabled but SSL_KEY_PATH or SSL_CERT_PATH not set');
    return { enabled: false };
  }

  try {
    const options: https.ServerOptions = {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath),
    };

    if (env.SSL_CA_PATH) {
      options.ca = fs.readFileSync(env.SSL_CA_PATH);
    }

    return { enabled: true, options };
  } catch (error) {
    console.error('Failed to load SSL certificates:', error);
    return { enabled: false };
  }
}
```

#### Step 1.3: Update Server Creation
**File:** `backend/src/app.ts`

Replace:
```typescript
import { createServer } from 'http';
// ...
const server = createServer(app);
```

With:
```typescript
import { createServer as createHttpServer } from 'http';
import { createServer as createHttpsServer } from 'https';
import { loadSSLConfig } from './config/ssl';
// ...
const sslConfig = loadSSLConfig(env);
const server = sslConfig.enabled && sslConfig.options
  ? createHttpsServer(sslConfig.options, app)
  : createHttpServer(app);
```

#### Step 1.4: Add HTTPS Redirect Middleware
**File:** `backend/src/middleware/httpsRedirect.ts` (new file)

```typescript
import { Request, Response, NextFunction } from 'express';

export function httpsRedirect(forceHttps: boolean) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (forceHttps && !req.secure && req.get('x-forwarded-proto') !== 'https') {
      return res.redirect(301, `https://${req.get('host')}${req.url}`);
    }
    next();
  };
}
```

#### Step 1.5: Add HSTS Headers
**File:** `backend/src/app.ts`

Add after helmet() middleware:
```typescript
// HSTS - Strict Transport Security (only in production with HTTPS)
if (env.NODE_ENV === 'production' && sslConfig.enabled) {
  app.use((_req, res, next) => {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
    next();
  });
}
```

#### Step 1.6: Update CORS Origins to Support HTTPS
**File:** `backend/src/app.ts`

Replace hardcoded HTTP origins with dynamic protocol:
```typescript
const getOrigins = () => {
  const protocol = sslConfig.enabled ? 'https' : 'http';
  return [
    `${protocol}://localhost:5173`,
    `${protocol}://192.168.1.58:5173`,
    env.FRONTEND_URL
  ];
};

const io = new Server(server, {
  cors: {
    origin: getOrigins(),
    methods: ["GET", "POST"]
  }
});

app.use(cors({
  origin: getOrigins(),
  credentials: true
}));
```

---

### Phase 2: Frontend Protocol-Aware URLs

#### Step 2.1: Create Protocol Utility
**File:** `frontend/src/utils/protocol.ts` (new file)

```typescript
/**
 * Protocol detection utility for secure connections
 */

export function getApiProtocol(): 'https' | 'http' {
  // In production, always prefer HTTPS
  if (import.meta.env.PROD) {
    return 'https';
  }

  // In development, match the page protocol
  if (typeof window !== 'undefined') {
    return window.location.protocol === 'https:' ? 'https' : 'http';
  }

  return 'http';
}

export function getWsProtocol(): 'wss' | 'ws' {
  return getApiProtocol() === 'https' ? 'wss' : 'ws';
}

export function buildApiBaseUrl(port: number = 3001, path: string = '/api/v1'): string {
  if (import.meta.env.VITE_API_URL) {
    return import.meta.env.VITE_API_URL;
  }

  const protocol = getApiProtocol();
  const hostname = typeof window !== 'undefined' ? window.location.hostname : 'localhost';

  return `${protocol}://${hostname}:${port}${path}`;
}

export function buildWsUrl(port: number = 3001): string {
  if (import.meta.env.VITE_API_URL) {
    const apiUrl = import.meta.env.VITE_API_URL;
    // Convert http(s) to ws(s)
    return apiUrl.replace(/^http/, 'ws').replace(/\/api\/v1$/, '');
  }

  const protocol = getWsProtocol();
  const hostname = typeof window !== 'undefined' ? window.location.hostname : 'localhost';

  return `${protocol}://${hostname}:${port}`;
}
```

#### Step 2.2: Update baseApi.ts
**File:** `frontend/src/services/api/baseApi.ts`

Replace the inline URL computation (lines 41-57) with:
```typescript
import { buildApiBaseUrl } from '../../utils/protocol';

// In constructor
constructor(baseURL: string = buildApiBaseUrl()) {
  this.baseURL = baseURL;
  this.loadToken();
}
```

#### Step 2.3: Update viewerApi.ts
**File:** `frontend/src/services/api/viewerApi.ts`

Replace `computeBaseURL()` function (lines 3-12) with:
```typescript
import { buildApiBaseUrl } from '../../utils/protocol';

const baseURL = buildApiBaseUrl();
```

#### Step 2.4: Update realTimeService.ts
**File:** `frontend/src/services/realTimeService.ts`

Replace the serverUrl computation (lines 382-395) with:
```typescript
import { buildWsUrl } from '../utils/protocol';

export const realTimeService = new RealTimeService({
  serverUrl: (() => {
    if (import.meta.env.VITE_API_URL) {
      // Convert API URL to WebSocket URL
      return import.meta.env.VITE_API_URL.replace(/^http/, 'ws').replace(/\/api\/v1$/, '');
    }
    return buildWsUrl();
  })(),
  reconnectionAttempts: Infinity,
  reconnectionDelay: 2000,
  timeout: 5000
});
```

---

### Phase 3: Environment Configuration

#### Step 3.1: Create Environment Example Files
**File:** `backend/.env.example` (new file)

```bash
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/football_events"

# Server
PORT=3001
NODE_ENV=development
FRONTEND_URL=http://localhost:5173

# Rate Limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=1000

# SSL/HTTPS Configuration (Production)
SSL_ENABLED=false
SSL_KEY_PATH=./certs/private.key
SSL_CERT_PATH=./certs/certificate.crt
SSL_CA_PATH=./certs/ca-bundle.crt
FORCE_HTTPS=false
```

**File:** `frontend/.env.example` (new file)

```bash
# API Configuration
# Leave empty for auto-detection, or set explicitly:
# VITE_API_URL=https://api.example.com/api/v1
VITE_API_URL=
```

---

### Phase 4: Test Updates

#### Step 4.1: Update Test Fixtures
**File:** `frontend/tests/integration/teams-api-integration.test.ts`

Replace:
```typescript
const BACKEND_URL = 'http://localhost:3001/api/v1';
```

With:
```typescript
const BACKEND_URL = process.env.VITE_API_URL || 'http://localhost:3001/api/v1';
```

#### Step 4.2: Update realTimeService Test
**File:** `frontend/tests/unit/services/realTimeService.test.ts`

The test uses a mock URL, which is acceptable. No changes required.

---

### Phase 5: Documentation Updates

#### Step 5.1: Create SSL Setup Guide
**File:** `documentation/ssl-setup-guide.md` (new file)

Document:
- How to generate self-signed certificates for development
- How to obtain Let's Encrypt certificates for production
- Environment variable configuration
- Reverse proxy setup (nginx/Apache)

---

## File Change Summary

### New Files
| File | Purpose |
|------|---------|
| `backend/src/config/ssl.ts` | SSL configuration loader |
| `backend/src/middleware/httpsRedirect.ts` | HTTP to HTTPS redirect |
| `frontend/src/utils/protocol.ts` | Protocol detection utilities |
| `backend/.env.example` | Backend environment template |
| `frontend/.env.example` | Frontend environment template |
| `documentation/ssl-setup-guide.md` | SSL setup documentation |

### Modified Files
| File | Changes |
|------|---------|
| `backend/src/config/env.ts` | Add SSL environment variables |
| `backend/src/app.ts` | HTTPS server, HSTS, dynamic CORS |
| `frontend/src/services/api/baseApi.ts` | Use protocol utility |
| `frontend/src/services/api/viewerApi.ts` | Use protocol utility |
| `frontend/src/services/realTimeService.ts` | Use WSS for WebSocket |
| `frontend/tests/integration/teams-api-integration.test.ts` | Environment-aware URL |

---

## Testing Checklist

- [ ] Backend starts with `SSL_ENABLED=false` (development mode)
- [ ] Backend starts with `SSL_ENABLED=true` and valid certificates
- [ ] HTTP requests redirect to HTTPS when `FORCE_HTTPS=true`
- [ ] HSTS header present in production with SSL
- [ ] Frontend auto-detects protocol from page URL
- [ ] WebSocket connects via WSS in HTTPS mode
- [ ] CORS allows both HTTP and HTTPS origins appropriately
- [ ] All existing tests pass
- [ ] Authentication tokens transmitted securely

---

## Rollback Plan

If issues arise:
1. Set `SSL_ENABLED=false` in backend environment
2. Frontend will auto-detect and use HTTP
3. No code changes required for rollback

---

## Security Considerations

1. **Certificate Management**: Certificates should not be committed to git
2. **Private Key Protection**: SSL_KEY_PATH file should have restricted permissions (600)
3. **Certificate Renewal**: Set up automated renewal for Let's Encrypt
4. **Development vs Production**: Use self-signed certs for dev, proper CA certs for prod
